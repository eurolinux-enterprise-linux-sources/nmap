diff -up nmap-6.40/nse_nsock.cc.sfdc02129088 nmap-6.40/nse_nsock.cc
--- nmap-6.40/nse_nsock.cc.sfdc02129088	2018-07-03 11:24:38.000000000 +0200
+++ nmap-6.40/nse_nsock.cc	2018-07-03 11:40:03.000000000 +0200
@@ -351,6 +351,15 @@ static void callback (nsock_pool nsp, ns
 {
   nse_nsock_udata *nu = (nse_nsock_udata *) ud;
   lua_State *L = nu->thread;
+  if (lua_status(L) == LUA_OK && nse_status(nse) == NSE_STATUS_ERROR) {
+    // Sometimes Nsock fails immediately and callback is called before
+    // l_connect has a chance to yield. TODO: Figure out how to return an error
+    // to the calling thread without falling into an infinite loop somewhere.
+    // http://seclists.org/nmap-dev/2016/q1/201
+    trace(nse_iod(nse), nu->action, nu->direction);
+    nsi_delete(nu->nsiod, NSOCK_PENDING_NOTIFY);
+    luaL_error(L, "Nsock immediate error");
+  }
   assert(lua_status(L) == LUA_YIELD);
   trace(nse_iod(nse), nu->action, nu->direction);
   status(L, nse_status(nse));
@@ -505,6 +514,9 @@ static int l_connect (lua_State *L)
   }
 
   nu->af = dest->ai_addr->sa_family;
+  nu->thread = L;
+  nu->action = "PRECONNECT";
+  nu->direction = TO;
 
   switch (what)
   {
